<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-CN">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta name="description" content="手册 java代码基本规范手稿 命名规范 修饰符顺序 代码性能 未分组 集合 字符串 不必要的代码开销   代码可读性 代码健壮性 未分组 空指针 数字操作 线程 内存   更好的实现        手册java代码基本规范手稿命名规范  命名规范包括方法，字段，类等等的命名规则，命名要保证易懂可识别，能够通过名称可以大致了其作用。  共同的  给名称赋予某种意义，比如util包下请统一类名">
<meta property="og:type" content="article">
<meta property="og:title" content="java编码规范">
<meta property="og:url" content="https://laoxshare.com/2020/06/17/java%E7%BC%96%E7%A0%81%E8%A7%84%E8%8C%83/index.html">
<meta property="og:site_name" content="我的博客">
<meta property="og:description" content="手册 java代码基本规范手稿 命名规范 修饰符顺序 代码性能 未分组 集合 字符串 不必要的代码开销   代码可读性 代码健壮性 未分组 空指针 数字操作 线程 内存   更好的实现        手册java代码基本规范手稿命名规范  命名规范包括方法，字段，类等等的命名规则，命名要保证易懂可识别，能够通过名称可以大致了其作用。  共同的  给名称赋予某种意义，比如util包下请统一类名">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2020-06-17T09:34:15.000Z">
<meta property="article:modified_time" content="2020-06-17T09:34:54.931Z">
<meta property="article:author" content="老许">
<meta name="twitter:card" content="summary">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://laoxshare.com/2020/06/17/java编码规范/"/>





  <title>java编码规范 | 我的博客</title>
  








<meta name="generator" content="Hexo 4.2.1"></head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">我的博客</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            Archives
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://laoxshare.com/2020/06/17/java%E7%BC%96%E7%A0%81%E8%A7%84%E8%8C%83/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="老许">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="我的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">java编码规范</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-06-17T17:34:15+08:00">
                2020-06-17
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <!-- TOC -->

<ul>
<li><a href="#手册">手册</a><ul>
<li><a href="#java代码基本规范手稿">java代码基本规范手稿</a><ul>
<li><a href="#命名规范">命名规范</a></li>
<li><a href="#修饰符顺序">修饰符顺序</a></li>
<li><a href="#代码性能">代码性能</a><ul>
<li><a href="#未分组">未分组</a></li>
<li><a href="#集合">集合</a></li>
<li><a href="#字符串">字符串</a></li>
<li><a href="#不必要的代码开销">不必要的代码开销</a></li>
</ul>
</li>
<li><a href="#代码可读性">代码可读性</a></li>
<li><a href="#代码健壮性">代码健壮性</a><ul>
<li><a href="#未分组-1">未分组</a></li>
<li><a href="#空指针">空指针</a></li>
<li><a href="#数字操作">数字操作</a></li>
<li><a href="#线程">线程</a></li>
<li><a href="#内存">内存</a></li>
</ul>
</li>
<li><a href="#更好的实现">更好的实现</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<!-- /TOC -->

<h1 id="手册"><a href="#手册" class="headerlink" title="手册"></a>手册</h1><h2 id="java代码基本规范手稿"><a href="#java代码基本规范手稿" class="headerlink" title="java代码基本规范手稿"></a>java代码基本规范手稿</h2><h3 id="命名规范"><a href="#命名规范" class="headerlink" title="命名规范"></a>命名规范</h3><p>  命名规范包括方法，字段，类等等的命名规则，命名要保证易懂可识别，能够通过名称可以大致了其作用。</p>
<ul>
<li><p>共同的</p>
<ol>
<li>给名称赋予某种意义，比如util包下请统一类名后缀Util 等等。</li>
<li>不建议在名称中出现 $ 等可用的特殊符号，除非特殊情况，一般是通过这些字符组成[a-z][a-zA-Z0-9]</li>
</ol>
</li>
<li><p>文件</p>
<ul>
<li>包（package）<ol>
<li>包名全部小写，且最好是全英文，不允许出现数字开头</li>
<li>一般我们命名规则 com.公司名.项目名.模块名….</li>
</ol>
</li>
<li>类（class）<ol>
<li>类名称首字符需要进行大写</li>
</ol>
</li>
<li>接口（interface）<ol>
<li>在class 规则上面建议使用 I 开头进行区别</li>
</ol>
</li>
<li>枚举（Enum）<ol>
<li>基本与 Class 的命名规范类似。在满足 Classd 命名规则的基础之上，保证开头第一个字母为 ”E” ，便于与普通的 Class区别开。</li>
</ol>
</li>
</ul>
</li>
<li><p>代码成员</p>
<ul>
<li>变量名称   <ol>
<li>变量名称建议使用驼峰命名方式，不推荐使用下划线方式</li>
<li>静态变量需要进行大写</li>
<li>常量字段 （Constants ） ，大写表示，并且字母之间通过  _ 连接</li>
</ol>
</li>
<li>方法<ol>
<li>方法名是一个动词，采用大小写混合的方式，第一个单词的首字母小写，其后单词的首字母大写。<br>方法名尽可能的描述出该方法的动作行为。返回类型为 Boolean 值的方法一般由“ is ”或“ has ”来开头。如： getCurrentUser()、addUser() 、hasAuthority()</li>
</ol>
</li>
</ul>
</li>
</ul>
<h3 id="修饰符顺序"><a href="#修饰符顺序" class="headerlink" title="修饰符顺序"></a>修饰符顺序</h3><pre><code>修饰符要按照规定的规范进行书写（规定如下）
  1. Annotations
  2. public
  3. protected
  4. private
  5. abstract
  6. static
  7. final
  8. transient
  9. volatile
  10. synchronized
  11. native
  12. strictfp</code></pre><h3 id="代码性能"><a href="#代码性能" class="headerlink" title="代码性能"></a>代码性能</h3><h4 id="未分组"><a href="#未分组" class="headerlink" title="未分组"></a>未分组</h4><ul>
<li>不应该使用构造函数来构造“String”，“BigInteger”，“BigDecimal”和原始包装类<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">貌似数字会出现精度误差</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h4><ul>
<li><p>定义集合变量，在定义集合的时候，等号右边的&lt;&gt;内不需要再写上元素类型，直接空着就行（基于jdk1.8功能，自动匹配类型）</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">void test()&#123;</span><br><span class="line">  List&lt;String&gt; a&#x3D;new ArrayList&lt;&gt;();&#x2F;&#x2F;后面的&lt;&gt;不需要指定，按时在定义集合变量类型请一定指定对应存储类型</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>判断集合非空的情况，不要通过使用.size()&gt;0 进行判断，使用collection.isEmpty()</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">void test()&#123;</span><br><span class="line">  List&lt;string&gt; list&#x3D;new ArrayList&lt;&gt;()；</span><br><span class="line">  dosomething();</span><br><span class="line">  if（list.size&gt;0）&#123;&#x2F;&#x2F;建议修改if(!collection.isEmpty())</span><br><span class="line">    &#x2F;*dosomething*&#x2F;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>对于集合局部临时存储变量，在后续操作中没有涉及修改的操作，请不要对其初始化</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">void test()&#123;</span><br><span class="line">  List&lt;string&gt; list&#x3D;new ArrayList&lt;&gt;()；&#x2F;&#x2F;此处不需要进行数据初始化</span><br><span class="line">  list&#x3D;get();</span><br><span class="line">  for(Strng str:list)&#123;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>在对map进行数据遍历的时候需要，如果只是需要遍历key，那么就keyset就行了，如果是同时需要key还有value那么就,那么就entrySet()</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">void test()&#123;</span><br><span class="line">  &#x2F;&#x2F;遍历key 值 ，不使用value</span><br><span class="line">  Map&lt;string,object&gt; map&#x3D;new HashMap();</span><br><span class="line">  for (String key:map.keySet()) &#123;</span><br><span class="line">      dosomething()</span><br><span class="line">  &#125;</span><br><span class="line"> &#x2F;*遍历key 值 ，使用value</span><br><span class="line"> 如果这里的map 没有对&lt;&gt;内的泛型进行制定，那么下面的代码将报错，所以对集合定义的时候一定要制定泛型</span><br><span class="line"> *&#x2F;</span><br><span class="line"> for (Map.Entry&lt;String,Object&gt; entry:map.entrySet()) &#123;</span><br><span class="line">    dosomething()</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h4><ul>
<li><p>不要使用同步的Vector/HashTable/Stack/StringBuffer等。在早期，出于线程安全问题考虑，java API 提供了这些类。但是同步会极大影响性能，即使是在同一个线程中使用他们。<br>对于字符串变量，也就是说，如果我们在代码中会修改字符串，那么使用stringbuilder，如果不修改那么使用stringbuffer</p>
<table>
<thead>
<tr>
<th align="center">名称</th>
<th align="center">stringbuffer</th>
<th align="center">string</th>
<th align="center">stringbuilder</th>
</tr>
</thead>
<tbody><tr>
<td align="center">性能</td>
<td align="center">最快</td>
<td align="center">较快</td>
<td align="center">块</td>
</tr>
<tr>
<td align="center">线程安全</td>
<td align="center">不安全</td>
<td align="center">不安全</td>
<td align="center">安全</td>
</tr>
</tbody></table>
</li>
<li><p>在单个字符处理上请直接使用单字符，不要使用字符串，比如indexof（’a’）时调查替换’str.indexof（“a”）’的效率</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">void test()&#123;</span><br><span class="line">  List&lt;String&gt; a&#x3D;new ArrayList&lt;&gt;();&#x2F;&#x2F;后面的&lt;&gt;不需要指定，按时在定义集合变量类型请一定指定对应存储类型</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>字符串不应该重复，如果多次用到同一字符串，建议将该字符串定义为字符串常量，再引用。</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">test0(&quot;aaa&quot;);</span><br><span class="line">test1(&quot;aaa&quot;);</span><br><span class="line">test2(&quot;aaa&quot;);</span><br><span class="line">&#x2F;&#x2F;应该在类中对 aaa这个字符串单独定义</span><br><span class="line"> private static final StringBuffer等 AAA&#x3D;new stirngbuffer(&quot;aaa&quot;);</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="不必要的代码开销"><a href="#不必要的代码开销" class="headerlink" title="不必要的代码开销"></a>不必要的代码开销</h4><ul>
<li><p>如果判断逻辑只是为了返回true或者false ，就不用写if else 直接 return 判断表达式就行了</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">boolean test()&#123;</span><br><span class="line">  if(expression)&#123;</span><br><span class="line">    return true;</span><br><span class="line">  &#125;else&#123;</span><br><span class="line">    return false;&#x2F;&#x2F;建议直接使用return expression；</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>在同一个条件结构中不能包含同样的分支操作</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">void test()&#123;</span><br><span class="line">  if()&#123;</span><br><span class="line">      system.out.println(&quot;ceshi&quot;)</span><br><span class="line">  &#125;else&#123;</span><br><span class="line">      system.out.println(&quot;ceshi&quot;)&#x2F;&#x2F;同一个结构块中不应该存在相同的块操作，应该去掉else 分支，对判断条件做优化</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>对于没有使用的引用应该删除</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">import java.util.Map;&#x2F;&#x2F;应该删除未使用的引用</span><br><span class="line">void test()&#123;</span><br><span class="line">  int a&#x3D;0;</span><br><span class="line">  system.out.println(&quot;ceshi&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>对没有使用变量应该删除</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">void test()&#123;</span><br><span class="line">  int a&#x3D;0; &#x2F;&#x2F;不需要，应该删除</span><br><span class="line">  system.out.println(&quot;ceshi&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>“抛出”声明不应该是多余的,如果它是以下情况：那么throws声明中的异常是多余的（实际压根不会被抛出） :</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1. 列出多次</span><br><span class="line">2. 列出的异常存在直接的继承关系</span><br><span class="line">3. RuntimeException或其后代之一</span><br></pre></td></tr></table></figure>
</li>
<li><p>本地变量如果赋值之后直接return了，那就直接return本地变量的赋值语句。</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int test()&#123;</span><br><span class="line">  int i&#x3D;get(a);</span><br><span class="line">  return i;&#x2F;&#x2F;直接return get(a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>如果在两个不存在包含关系的catch中处理的块是一样的话，那么java7支持对两者进行合并成一个catch块 (jdk 1.7 新特性 )</strong></p>
<p> <em>请注意，对于两个合并的异常类，不能存在直接的包含关系，也就是某一个类不能是另一个类的子类</em></p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">int test()&#123;</span><br><span class="line">  try()&#123;</span><br><span class="line"></span><br><span class="line">  &#125;catch(IOExption e)&#123;</span><br><span class="line">      dosomething();</span><br><span class="line">  &#125;catch(RuntimeException e)&#123;</span><br><span class="line">      dosomething();&#x2F;&#x2F;和上一个catch块一样的操作的话</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;请做一下合并</span><br><span class="line">int test()&#123;</span><br><span class="line">  try()&#123;</span><br><span class="line"></span><br><span class="line">  &#125;catch(IOExption | RuntimeException e)&#123;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>使用try-catch-resource 不要手动使用finally 进行资源的关闭（jdk1.7新特性）</strong></p>
<p><em>请注意，对于放于try（）内初始化的变量，只在try块内可见，并且定义的变量必须是声明继承closeable的类</em></p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">      void test()&#123;</span><br><span class="line">        try&#123;</span><br><span class="line">          InputStream in&#x3D;new FileInputStream()；</span><br><span class="line">          &#x2F;&#x2F;dosomething</span><br><span class="line">        &#125;catch(IOExption e)&#123;</span><br><span class="line">            dosomething();</span><br><span class="line">        &#125;finally&#123;</span><br><span class="line">          try&#123;</span><br><span class="line">            if(in !&#x3D;null)&#123;</span><br><span class="line">              in.close();</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F;dosomething</span><br><span class="line">          &#125;catch(IOExption e)&#123;</span><br><span class="line">              dosomething();</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      &#x2F;&#x2F;使用try()-&gt;catch-&gt;resource</span><br><span class="line">      void test(  )&#123;</span><br><span class="line">        try( InputStream in&#x3D;new FileInputStream()；)&#123;</span><br><span class="line">          &#x2F;&#x2F;dosomething</span><br><span class="line">        &#125;catch(IOExption e)&#123;</span><br><span class="line">            dosomething();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#96;&#96;&#96;         </span><br><span class="line"></span><br><span class="line">###  代码可读性</span><br><span class="line"></span><br><span class="line">- 首先需要严格遵循java的基本的规范，除非非常情况下</span><br><span class="line"></span><br><span class="line">- 工具类不应该包含公共的构造器，如果该类被认为不需要实例化，那么请定义一个private的构造方法</span><br><span class="line"></span><br><span class="line">- **只包含一个方法的匿名内部类应该写成Lambdas表达式的形式，增强代码可读(jdk 1.8新特性)**</span><br><span class="line"></span><br><span class="line">- **对于字符集如UTF-8 等编码集合使用 StandardCharsets （jdk1.7新特性）**</span><br></pre></td></tr></table></figure>
<pre><code>int test(){
  this.isUTF8 = cs.name().equals(&quot;UTF-8);
  // 修改使用下面的字符变量
  this.isUTF8 = cs.name().equals(StandardCharsets.UTF_8);
}</code></pre>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">-  不应该在代码中出现大量的注释，应该尽可能少的添加注释，除非非常必要的情况下</span><br><span class="line"></span><br><span class="line">-  Double Brace Initialization（DBI） 不要使用该方式创建一个集合类，不具有良好的可读性</span><br></pre></td></tr></table></figure>
<pre><code>class Tests{
  final Set&lt;String&gt; exclusions = new HashSet&lt;&gt;() {{
            add(‘Alice’);
            add(‘Bob’);
            add(‘Marine’);
        }};
  //使用以下方式
  final Set&lt;String&gt; exclusions = new HashSet&lt;String&gt;()；
  static{
    exclusions.  add(‘Alice’);
    exclusions.  add(‘Bob’);
    exclusions.  add(‘Marine’);
  }
}</code></pre>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 不要直接抛Error,RuntimeException&#x2F;Throwable&#x2F;Exception这样的通用的异常</span><br></pre></td></tr></table></figure>
<pre><code>请提供他们的子类，并且给出具体的意义，而不应该直接抛出这些基本的异常类。</code></pre>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 方法认知度不应该太高，也就是代码中不应该包含大量的if-else 的结构判断</span><br><span class="line"></span><br><span class="line">###  代码健壮性</span><br><span class="line">#### 未分组</span><br><span class="line"></span><br><span class="line">- Serializable类中的字段本身必须是Serializable或transient。</span><br><span class="line">  即使该类从未显式序列化或反序列化。对于不需要进行序列化的类，那么需要使用transient进行修饰。并且如果是内部类需要被序列化，那么请将内部类定义为静态内部类，因为有时候外部类不需要序列化，但是如果内部类进行序列化而该内部类不是静态内部类的情况下，那么程序会尝试去序列化该外部类，那么程序会出现异常。</span><br><span class="line"></span><br><span class="line">- &quot;InterruptedException&quot; 异常不应该被忽略。</span><br><span class="line">  因为往往抛出该异常的方法是执行无法预计的，可能存在内部阻塞的情况，所以当我们捕获到到该异常的情况下，我们需要进行手动的 Thread.currentThread().interrupt();要求程序立即返回，不在等待响应</span><br><span class="line">。</span><br><span class="line">- clone 方法不应该被重写，如果最后你只是调用了super.colne()。</span><br><span class="line">  Joshua Bloch表示，许多人认为克隆和Cloneable在Java中被破坏，很大程度上是因为重写克隆的规则很棘手，很难做到正确。</span><br><span class="line">  Object的clone方法非常棘手。 它基于现场副本，而且是“超语言”。 它创建一个对象而不调用构造函数。 无法保证它保留构造函数建立的不变量。 多年来，在Sun内外都存在许多错误，这源于这样一个事实，即如果你只是反复调用super.clone直到克隆了一个对象，那么你就拥有了一个浅层的对象副本。 克隆通常与正在克隆的对象共享状态。 如果该状态是可变的，则您没有两个独立的对象。 如果您修改一个，另一个也会更改。 突然之间，你会得到随机行为。</span><br><span class="line">  应该使用复制构造函数或复制工厂。</span><br><span class="line">  无论是否实现Cloneable，此规则都会在重写克隆时引发问题。（*如果要重写 请解决好 深复制 浅复制的问题*）</span><br><span class="line"></span><br><span class="line">- uri不应该是硬编码的。</span><br><span class="line">  对URI进行硬编码会使测试程序变得困难：路径文字并不总是可以跨操作系统移植，特定测试环境中可能不存在给定的绝对路径，执行测试时，指定的Internet URL可能不可用，生产环境 文件系统通常与开发环境不同，等等。 出于所有这些原因，URI永远不应该被硬编码。 相反，它应该由可自定义的参数替换。</span><br></pre></td></tr></table></figure>
<pre><code>void test(){
  Url url=new Url (base url +&quot;/&quot;+&quot;&quot;);//不应该使用硬编码“/”
  //对于访问路径 使用File 工具类 或者http工具类支持的常量
}</code></pre>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#### 空指针</span><br><span class="line"></span><br><span class="line">- 方法返回集合或者数组，不应该直接返回null，应该有可能在上一级的调用中出现空指针异常，推荐使用Collections.emptyList()，返回一个空列表。</span><br><span class="line"></span><br><span class="line">- 定义非空变量的时候，在后续调用方法时有可能出现空指针异常。如果没有显示的初始化的情况下，一定做好判断。</span><br><span class="line"></span><br><span class="line">#### 数字操作</span><br><span class="line"></span><br><span class="line">- 如果一个变量被定义为 0 ，那额在接下来的触发操作中，需要进行判断是是否该值为非0数据</span><br><span class="line"></span><br><span class="line">- 不应该使用构造函数来构造“String”，“BigInteger”，“BigDecimal”和原始包装类</span><br></pre></td></tr></table></figure>
<pre><code>这个构造函数的结果可能有点不可预测。 有人可能会假设在Java中编写新的BigDecimal（0.1）会创建一个BigDecimal，它恰好等于0.1（未缩放值为1，标度为1），但它实际上等于0.1000000000000000055511151231257827021181583404541015625。 这是因为0.1不能精确地表示为double（或者，就此而言，作为任何有限长度的二进制分数）。 因此，传递给构造函数的值并不完全等于0.1，尽管有外观。
    相反，您应该使用BigDecimal.valueOf，它使用封面下的字符串来消除浮点舍入错误，或者使用String参数的构造函数。
至于string 以及其他基本类型德华 应该是出于性能考虑吧。</code></pre>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">- 数字操作在操作或赋值前要转化</span><br><span class="line">  对整数执行算术运算时，结果将始终为整数。 您可以使用自动类型转换将结果分配给long，double或float，但是以int或long开头，结果可能不是您所期望的。</span><br><span class="line">  例如，如果将int division的结果赋给浮点变量，则在赋值之前精度将丢失。 同样，如果乘法结果被赋值为long，则它可能在赋值之前已经溢出。</span><br><span class="line">  在任何一种情况下，结果都不会是预期的结果。 相反，在操作发生之前，应该至少将一个操作数强制转换或提升为最终类型。也就是高精度向低精度强转的时候会出现精度丢失。</span><br><span class="line">  byte-&gt;short-&gt;int-&gt;long-&gt;float-&gt;double（精度最大）</span><br><span class="line"></span><br><span class="line">#### 线程</span><br><span class="line"></span><br><span class="line">- 循环的指示器，不能再循环块中进行改变，除非你能保证在原子性上面能够保证线程安全，否则不要试图在循环体里面修改循环指示器</span><br><span class="line"></span><br><span class="line">- 不要试图使用volatile 保证数据的可见性。</span><br></pre></td></tr></table></figure>
<pre><code>意思就是非基本类型，引用类型的话声明volatile，保证的是引用永远是最新的，但是它的值却不是最新的，其他线程可能不能及时看到这个引用的最新的值数据，所以不能通过volatile保证引用对象的数据可见性。但是如果在后续的操作中没有修改操作的话，volatile添加这个修饰是有效的</code></pre>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#### 内存</span><br><span class="line"></span><br><span class="line">### 更好的实现</span><br><span class="line"></span><br><span class="line">- 对于重新equals（）方法的类，请同样实现hashcode方法</span><br></pre></td></tr></table></figure>
<pre><code>这两个方法永远要一起被重写
根据Java语言规范，equals（Object）和hashCode（）之间存在契约：
如果两个对象根据equals（Object）方法相等，则对两个对象中的每一个调用hashCode方法必须生成相同的整数结果。
如果两个对象根据equals（java.lang.Object）方法不相等，则不需要在两个对象中的每一个上调用hashCode方法必须生成不同的整数结果。
但是，程序员应该知道为不等对象生成不同的整数结果可能会提高哈希表的性能。
为了遵守本合同，这些方法既可以是继承的，也可以是重写的。
并且equals 方法请遵循下面的判断顺序

boolean equals(obj){
  if(obj ==null){
    return false;//首先判断非空
  }
  if(this.getClass()!=obj.getClass()){
      return false;//对类型做判断
  }
  //最后对值做判断，往往我们会忽视前两步
}</code></pre>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- 请使用专用的日志记录器，不要使用System.</span><br></pre></td></tr></table></figure>
<pre><code>记录消息时，必须满足几个重要要求：
  用户必须能够轻松检索日志
  所有记录消息的格式必须统一，以便用户轻松读取日志
  必须实际记录记录的数据
  只能安全地记录敏感数据
  如果程序直接写入标准输出，则绝对无法满足这些要求。 这就是强烈建议定义和使用专用记录器的原因。</code></pre>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 使用logger 打印日志的时候，在方法内使用+ 进行字符串拼接操作，应该是用logger提供的占用符操作</span><br></pre></td></tr></table></figure>
<pre><code>void test(){
  logger.info(&quot;打印 {} 到 {}&quot;,&quot;a&quot;，&quot;这里&quot;);
}</code></pre>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- 对于有返回值的依赖三方的方法，请最好对其进行使用（Return values from functions without side effects should not be ignored）</span><br></pre></td></tr></table></figure>
<p>  void test（）{</p>
<pre><code>commad.toLowerCase();//并没有改变原值，请使用返回值</code></pre><p>  }<br>  当对函数的调用没有任何副作用时，如果结果被忽略，那么调用的重点是什么？ 在这种情况下，函数调用是无用的，应该被删除或源代码不按预期运行。</p>
<pre><code>为了防止生成任何误报，此规则仅在Java API中的以下预定义的不可变类列表中触发问题：
java.lang.String中
java.lang.Boolean的
为java.lang.Integer
java.lang.Double中
java.lang.Float中
java.lang.Byte中
java.lang.Character中
java.lang.Short中
java.lang.StackTraceElement中
java.time.DayOfWeek
java.time.Duration
java.time.Instant
java.time.LocalDate
java.time.LocalDateTime
java.time.LocalTime
java.time.Month
java.time.MonthDay
java.time.OffsetDateTime
java.time.OffsetTime
java.time.Period
java.time.Year
java.time.YearMonth
java.time.ZonedDateTime
java.math.BigInteger中
java.math.BigDecimal中
java.util.Optional
并且还对ConcurrentMap.putIfAbsent调用忽略了返回值。</code></pre><pre><code></code></pre></li>
</ul>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2020/06/17/jdbc/" rel="next" title="jdbc">
                <i class="fa fa-chevron-left"></i> jdbc
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2020/07/21/%E6%90%AD%E5%BB%BAgitlab/" rel="prev" title="搭建gitlab">
                搭建gitlab <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            Table of Contents
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            Overview
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">老许</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/%7C%7Carchive">
              
                  <span class="site-state-item-count">22</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            

            
              
              
              <div class="site-state-item site-state-tags">
                
                  <span class="site-state-item-count">13</span>
                  <span class="site-state-item-name">tags</span>
                
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#手册"><span class="nav-number">1.</span> <span class="nav-text">手册</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#java代码基本规范手稿"><span class="nav-number">1.1.</span> <span class="nav-text">java代码基本规范手稿</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#命名规范"><span class="nav-number">1.1.1.</span> <span class="nav-text">命名规范</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#修饰符顺序"><span class="nav-number">1.1.2.</span> <span class="nav-text">修饰符顺序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#代码性能"><span class="nav-number">1.1.3.</span> <span class="nav-text">代码性能</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#未分组"><span class="nav-number">1.1.3.1.</span> <span class="nav-text">未分组</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#集合"><span class="nav-number">1.1.3.2.</span> <span class="nav-text">集合</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#字符串"><span class="nav-number">1.1.3.3.</span> <span class="nav-text">字符串</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#不必要的代码开销"><span class="nav-number">1.1.3.4.</span> <span class="nav-text">不必要的代码开销</span></a></li></ol></li></ol></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">老许</span>

  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
